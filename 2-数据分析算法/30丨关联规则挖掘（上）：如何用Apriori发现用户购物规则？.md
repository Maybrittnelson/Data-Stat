[TOC]



在今天的内容中，希望你能带着问题，和我一起搞懂以下几个知识点：

1. 搞懂关联规则中的几个重要概念：支持度、置信度、提升度；
2. Apriori 算法的工作原理；
3. 在实际工作中，我们该如何进行关联规则挖掘。

## 搞懂关联规则中的几个概念

![img](https://static001.geekbang.org/resource/image/f7/1c/f7d0cc3c1a845bf790b344f62372941c.png)

### 什么是支持度呢？

支持度是个百分比，它指的是某个商品组合出现的次数和总次数之间的比例。

“牛奶” 出现了 4 次，那么这 5 笔订单中“牛奶”的支持度就是 4/5=0.8。

同样“牛奶 + 面包”出现了 3 次，那么这 5 笔订单中“牛奶 + 面包”的支持度就是 3/5=0.6。

### 什么是置信度呢？

它指的就是当你购买了商品A，会有多大的概率购买商品 B，在上面这个例子中：

置信度（牛奶 —> 啤酒）=2/4=0.5，代表如果你购买了牛奶，有多大的概率会购买啤酒？

置信度（啤酒 —> 牛奶）=2/3=0.67，代表如果你购买了啤酒，有多大的概率会购买牛奶？

### 什么是提升度呢？

我们在做商品推荐的时候，重点考虑的是提升度，因为提升度代表的是“商品A的出现，对商品B的出现概率提升的”程度。

单从置信度（可乐 —> 尿布）=1，也就是说可乐出现的时候，用户会购买尿布，那么当用户购买可乐的时候，我们就需要推荐尿布么？

提升度（A—>B）=置信度（A—>B）/ 支持度（B）

所以提升度有三种可能：

1. 提升度（A —> B）> 1：代表有提升。
2. 提升度（A—>B）=1：代表有没有提升，也没有下降。
3. 提升度（A—>B）<1：代表有下降。

## Apriori 的工作原理

首先我们把上面案例中的商品用 ID 来代表，牛奶、面包、尿布、可乐、啤酒、鸡蛋的商品 ID 分别设置为 1-6，上面的数据表可以为：

![img](https://static001.geekbang.org/resource/image/e3/33/e30fe11a21191259e6a93568461fa933.png)

 Apriori 算法其实就是查找频繁项集（frequent itemset）的过程，所以首先我们需要定义什么是频繁项集。

频繁项集就是支持度大于等于最小支持度（Min Support）阀值的项集，所以小于最小值支持度的项目就是非频繁项集，而大于等于最小支持度的项集就是频繁项集。

假设我随机指定最小支持度是 50%，也就是0.5。

首先，我们先计算单个商品的支持度，也就是得到K=1项的支持度：

![img](https://static001.geekbang.org/resource/image/ff/de/fff5ba49aff930bba71c98685be4fcde.png)

因为最小支持度是0.5，所以你能看到商品4、6是不符合最小支持度的。于是经过筛选商品的频繁项集就变成：

![img](https://static001.geekbang.org/resource/image/ae/b6/ae108dc65c33e9ed9546a0d91bd881b6.png)

在这个基础上，我们将商品两两组合，得到 k=2项的支持度

![img](https://static001.geekbang.org/resource/image/a5/a3/a51fd814ebd68304e3cb137630af3ea3.png)

我们再筛掉小于最小值支持度的商品组合，可以得到：

![img](https://static001.geekbang.org/resource/image/a0/c8/a087cd1bd2a9e033105de275834b79c8.png)

我们再将商品进行 K=3 项的商品组合，可以得到：

![img](https://static001.geekbang.org/resource/image/a7/9c/a7f4448cc5031b1edf304c9aed94039c.png)

再筛掉小于最小值支持度的商品组合，可以得到：

![img](https://static001.geekbang.org/resource/image/d5/0f/d51fc9137a537d8cb96fa21707cab70f.png)

Apriori 算法的流程，下面我来给你总结下 Apriori 算法的递归流程：

1. K=1，计算 K 项集的支持度；
2. 筛选掉小于最小支持度的项集；
3. 如果项集为空，则对应 K-1项集的结果为最终结果。

## Apriori 的改进算法：FP-Growth 算法

Apriori 在计算的过程中有以下几个缺点：

1. 可能产生大量的候选集。因为采用排列组合的方式，把可能的项集都组合出来了；
2. 每次计算都需要重新扫描数据集，来计算每个项集的支持度。

### 1. 创建项头表（item header table）

创建项头表的作用是为 FP 创建及频繁挖掘提供索引。

这一步的流程是先扫描一遍数据集，对于满足最小支持度的单个项（K=1 项集）按照支持度从高到低进行排序，这个过程中**删除了不满足最小支持度的项**（删除最小支持度可乐2）。

![img](https://static001.geekbang.org/resource/image/69/f5/69ce07c61a654faafb4f5114df1557f5.png)

### 2. 构造 FP 树

FP 树的根节点记为 NULL 节点，再次扫描数据集，对于每一条数据，按照支持度从高到低的顺序进行创建节点（项头表中的排序结果），并更新节点技术和项头表中的链表。

![img](https://static001.geekbang.org/resource/image/ea/92/eadaaf6585379815e62aad99386c7992.png)

### 3. 通过 FP 树挖掘频繁项集

通过 FP 树挖掘频繁项集，运用到 “条件模式基”的概念，它指的是以要挖掘的节点为叶子节点，自底向上求出 FP 子树，然后将 FP 子树的祖先节点设置为叶子节点之和。

挖掘的节点为叶子节点为“啤酒”，自底向上求出 FP子树。但是啤酒的叶子节点全为1，小于最小支持度可乐的2，所以删除所有啤酒叶子节点，所以“条件模式基”

![img](https://static001.geekbang.org/resource/image/99/0f/9951cda824fc9823136231e7c8e70d0f.png)

